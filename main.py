import os
import spotipy
import csv
import argparse
from spotipy.oauth2 import SpotifyOAuth
from dotenv import load_dotenv
from tqdm import tqdm

# Load environment variables
load_dotenv()

# Configuration
CLIENT_ID = os.getenv("SPOTIPY_CLIENT_ID")
CLIENT_SECRET = os.getenv("SPOTIPY_CLIENT_SECRET")
REDIRECT_URI = os.getenv("SPOTIPY_REDIRECT_URI")
SCOPE = "playlist-modify-private"

def authenticate():
    """Authenticates the user using SpotifyOAuth."""
    return spotipy.Spotify(auth_manager=SpotifyOAuth(
        client_id=CLIENT_ID,
        client_secret=CLIENT_SECRET,
        redirect_uri=REDIRECT_URI,
        scope=SCOPE,
        cache_path=".spotify_cache"
    ))

def read_songs_from_file(filename):
    """
    Reads songs from a .txt or .csv file.
    Returns a list of search queries.
    """
    songs = []
    if not os.path.exists(filename):
        print(f"‚ùå File '{filename}' not found.")
        return []

    print(f"üìÇ Reading from {filename}...")
    
    with open(filename, 'r', encoding='utf-8-sig') as f:
        if filename.endswith('.csv'):
            reader = csv.reader(f)
            next(reader, None)  # Skip header
            
            for row in reader:
                if not row: continue 
                row = [str(item).strip() for item in row if item]
                
                if len(row) >= 2:
                    # Column 0: Track, Column 1: Artist
                    query = f"track:{row[0]} artist:{row[1]}"
                    songs.append(query)
                elif len(row) == 1:
                    # Smart parsing for single column
                    raw_text = row[0]
                    if " ‚Äì " in raw_text:
                        parts = raw_text.split(" ‚Äì ", 1)
                        query = f"artist:{parts[0]} track:{parts[1]}"
                    elif " - " in raw_text:
                        parts = raw_text.split(" - ", 1)
                        query = f"artist:{parts[0]} track:{parts[1]}"
                    else:
                        query = raw_text
                    songs.append(query)
        else:
            songs = [line.strip() for line in f if line.strip()]

    return songs

def get_track_ids(sp, song_list):
    """
    Searches for tracks and returns their Spotify IDs.
    Restricts search to the user's current market to ensure playability.
    """
    track_ids = []
    not_found = []

    print(f"\nüîé Searching for {len(song_list)} songs...")

    for query in tqdm(song_list, unit="song"):
        try:
            # market='from_token' ensures the song is available in your region (Ghana)
            result = sp.search(q=query, limit=1, type='track', market='from_token')
            tracks = result['tracks']['items']
            
            if tracks:
                track_ids.append(tracks[0]['uri'])
            else:
                not_found.append(query)
        except Exception as e:
            not_found.append(query)
            
    return track_ids, not_found

def chunk_list(data, size):
    """Yield successive n-sized chunks from data."""
    for i in range(0, len(data), size):
        yield data[i:i + size]

def create_playlist(sp, user_id, name, track_ids):
    """Creates a playlist and adds tracks in batches."""
    if not track_ids:
        print("No tracks found. Skipping playlist creation.")
        return

    print(f"\n‚ú® Creating playlist: '{name}'...")
    
    playlist = sp.user_playlist_create(
        user=user_id, 
        name=name, 
        public=False, 
        description="Generated by Caleb via Python üêç"
    )
    
    playlist_id = playlist['id']
    batches = list(chunk_list(track_ids, 100))
    
    print(f"üì¶ Uploading {len(track_ids)} tracks in {len(batches)} batches...")
    
    for batch in batches:
        sp.playlist_add_items(playlist_id=playlist_id, items=batch)
    
    print(f"üöÄ Success! Playlist '{name}' is ready.")

def save_missing_songs(missing_list):
    """Saves songs that weren't found to a text file."""
    if not missing_list: 
        return
    
    filename = "missing_songs.txt"
    with open(filename, "w", encoding="utf-8") as f:
        f.write("The following songs could not be found on Spotify:\n")
        f.write("=================================================\n")
        for song in missing_list:
            f.write(f"{song}\n")
            
    print(f"\n‚ö†Ô∏è  {len(missing_list)} songs were not found.")
    print(f"üìù List saved to '{filename}' for review.")

if __name__ == "__main__":
    # --- ARGUMENT PARSING ---
    parser = argparse.ArgumentParser(description="Generate Spotify Playlists from text/csv files.")
    parser.add_argument("-f", "--file", required=True, help="Path to the input CSV or TXT file")
    parser.add_argument("-n", "--name", required=True, help="Name of the playlist to create")
    
    args = parser.parse_args()

    # --- EXECUTION ---
    try:
        sp = authenticate()
        user = sp.current_user()
        print(f"Logged in as: {user['display_name']} ({user['id']})")

        # 1. Load songs from CLI argument
        queries = read_songs_from_file(args.file)

        if queries:
            # 2. Search
            valid_ids, missing = get_track_ids(sp, queries)

            # 3. Create Playlist with CLI name
            if valid_ids:
                create_playlist(sp, user['id'], args.name, valid_ids)

            # 4. Report & Log Errors
            save_missing_songs(missing)
        else:
            print("No songs to process. Check your file format.")

    except Exception as e:
        print(f"‚ùå Critical Error: {e}")